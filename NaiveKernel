kernel = """
#include <pyopencl-complex.h>   
__kernel void func_squaremet( __global cfloat_t* MatAdjP,__global cfloat_t* r, __global cfloat_t* MatQ,__global cfloat_t* QAMconstell,int N,int sizeQAM, int frobNorm,__global float* square_met	) {
	/* Pick any two symbols from the constellation. this is x3 and x4 */
	cfloat_t s_bar[2][1];
	cfloat_t c_bar[2][1];
	cfloat_t temp1[2][1];
	cfloat_t temp2[2][1];
	cfloat_t temp3[2][1];
	float square_met[sizeQAM*sizeQAM] = 0.0;
	float value = 0.0;
	float minS = 0.0 ;
	indexr = get_global_id(0);
	for (int i = 0 ; i <  sizeQAM ; i++)
	{
		for(int j = 0 ; j < sizeQAM ; j++)
		{
           s_bar[2][1] = { {QAMconstell[i]} , {QAMconstell[j]} }; 
           
           /* Calculating c_bar from s_bar */

           temp1[0][0] = MatQ[0][0] * s_bar[0][0] + MatQ[0][1] * s_bar[1][0];
           temp1[1][0] = MatQ[1][0] * s_bar[0][0] + MatQ[1][1] * s_bar[1][0];

           temp2[2][1] = { {r[indexr] - temp1[0][0] } , {r[indexr + N] - temp1[1][0]} };
           temp3[0][0] =  MatAdjP[0][0] * temp2[0][0] + MatAdjP[0][1] * temp2[1][0] ;
           temp3[1][0] =  MatAdjP[1][0] * temp2[0][0] + MatAdjP[1][1] * temp2[1][0] ;
           c_bar[2][1] =  { { (2/frobNorm) * temp3[0][0] } , { (2/frobNorm) * temp3[1][0] } };

           /* Code to calculate Frobenius norm and store it in square_met*/
 
    	   for(int i = 0; i < 2; i++)
    	   {
        		for(int j = 0; j < 1; j++)
        		{
            		value = abs(*(matrix + i + j)) * abs(*(matrix + i + j));
        		}
    	    }
            square_met[(i*sizeQAM)+j] = sqrt(result);

 		}
	}
	/*Calculate minimum of Metric value*/
	minS = square_met[0]
    for (int i = 1 ; i < (sizeQAM * sizeQAM) ; i++)
    {
    	if(minS > square_met[i])
    	minS = square_met[i]
    }
    
}


"""
#N = no of symbols. Received signal r is 2xN
